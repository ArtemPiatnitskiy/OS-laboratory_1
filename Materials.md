# Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы.

В процессе решения возникают вопросы, в которых необходимо разобраться. Информацию я нахожу в интернете, или спрашиваю у нейросетей.

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

Это помогает **глубже** разобраться в вопросе и сделать для себя материал, который поможет понять и запомнить важные моменты и понятия.

---

# Процессы — что это и как они организованы

- Процесс — это экземпляр выполняемой программы. У каждого процесса своя виртуальная память, таблица открытых файлов (file descriptors), ID процесса (PID), родитель (PPID) и набор ресурсов (регистры, текущее состояние).
- Контекст процесса: текст (код), данные (heap, global), стек, таблица дескрипторов файлов.
- Когда процесс создаётся, ОС создает ему отдельный адресный простор — поэтому два процесса не мешают друг другу напрямую (только через механизмы IPC).

# Threads (потоки) — отличия от процессов

- Поток (thread) — лёгкий поток выполнения внутри процесса. Потоки одного процесса разделяют память и дескрипторы файлов.
- Из-за разделяемой памяти потоки легче синхронизировать, но и легче допустить гонки (race conditions).
- В контексте задания мы используем процессы (`fork` + `exec`), не потоки; это важно, потому что дочерние процессы должны быть разными программами.

# File descriptors (дескрипторы файлов)

Файловый дескриптор — это уникальный числовой идентификатор, который операционная система присваивает открытому файлу, устройству, каналу или другому ресурсу ввода-вывода. Он позволяет процессам обращаться к этим ресурсам, управлять ими и выполнять операции чтения-записи данных. В Unix-подобных системах дескрипторы используются для взаимодействия с файлами, каталогами, сокетами и устройствами, а стандартные потоки ввода, вывода и ошибок имеют дескрипторы 0, 1 и 2 соответственно.

1. **Открытие ресурса:** 
   
   Когда программа открывает файл или создает другой объект ввода-вывода, операционная система выделяет для него запись в своей таблице и присваивает ей уникальный числовой дескриптор. 

2. **Использование дескриптора:** 
   
   Процесс использует этот дескриптор в качестве ссылки для выполнения системных вызовов, таких как чтение, запись или закрытие. 

3. **Таблица дескрипторов:** 
   
   Каждый процесс имеет свою таблицу открытых дескрипторов. В этой таблице индекс — это сам дескриптор, а значение — структура данных, хранящая информацию об открытом ресурсе. ([Полезный материал](https://serverspace.ru/support/glossary/deskriptor-fajla/?utm_source=google.com&utm_medium=organic&utm_campaign=google.com&utm_referrer=google.com))
- В UNIX-подобных системах дескриптор — это целое число, индекс таблицы открытых дескрипторов в процессе.
- **Стандартные дескрипторы**: Это заранее определенные дескрипторы, которые автоматически открыты для каждого процесса:0 — стандартный ввод (stdin).1 — стандартный вывод (stdout).2 — стандартный вывод ошибок (stderr).
- Файловые дескрипторы наследуются при fork(): дочерний процесс получает копию таблицы дескрипторов (указывающую на те же открытые файлы/пайпы). При exec() дескрипторы остаются открытыми, если не установлен флаг close-on-exec (FD_CLOEXEC).
- dup/dup2/dup3 позволяют "переназначить" дескрипторы: dup2(fd, STDIN_FILENO) заменит stdin новым fd.

## Как файлы получают дескрипторы

Обычно файловые дескрипторы выделяются последовательно. Есть пул свободных номеров. Когда вы создаете новый файл или открываете существующий, ему присваивается номер. Следующий файл получает очередной номер — например, 101, 102, 103 и так далее.

Дескриптор для каждого процесса является уникальным.

<img title="" src="https://content.timeweb.com/assets/4c3522f2-3c03-4c64-9583-60107791b801.png?width=600&height=295" alt="" data-align="center">

---

# fork() и exec() — как создают процессы

- `fork()` — клонирует процесс: возвращает **0** в дочернем, **PID** дочернего в родительском. После `fork()` родитель и ребёнок продолжают с той же точки.
- `execve` (и семейство `exec*`) заменяет текущий процесс новым образом программы, сохраняя PID. Часто вызывают fork(), затем в дочернем exec чтобы запустить другую программу.
- Практический паттерн: `parent: create pipes -> fork child -> in child: set up dup2() для stdin/stdout -> exec(child-program).`

## fork()

- `fork()` создает новый процесс, который является точной копией родительского процесса. Этот новый процесс называется дочерним процессом.
- **Как работает:**
  1. Когда вызывается `fork()`, операционная система создает дубликат адресного пространства родительского процесса. Это включает в себя копию кода, данных, стека, открытых файлов и других ресурсов.
  2. После создания дочернего процесса оба процесса (родительский и дочерний) продолжают выполнение с точки вызова `fork()`.
  3. `fork()` возвращает разные значения в родительском и дочернем процессах:
     - В родительском процессе `fork()` возвращает PID (идентификатор процесса) дочернего процесса.
     - В дочернем процессе `fork()` возвращает 0.
     - В случае ошибки `fork()` возвращает отрицательное значение.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid;

    pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        // Это дочерний процесс
        printf("Дочерний процесс: PID = %d, Родительский PID = %d\n", getpid(), getppid());
    } else {
        // Это родительский процесс
        printf("Родительский процесс: PID = %d, Дочерний PID = %d\n", getpid(), pid);
    }

    return 0;
}
```

По сути fork - это клонирование исходного процесса

## exec()

`exec()` – это функция, которая заменяет текущую программу другой программой. Это не клонирование, а скорее "перевоплощение".

- **Что происходит:** Когда вызывается `exec()`, текущий процесс заменяется новой программой. Код, данные и другие ресурсы текущего процесса заменяются ресурсами новой программы.

- **Возвращаемое значение:** `exec()` возвращает значение только в случае ошибки. Если вызов `exec()` успешен, текущая программа будет заменена новой, и дальнейший код в текущей программе не будет выполнен.

- **Для чего это нужно:** `exec()` используется для запуска других программ из текущей программы. Например, командная оболочка (вроде bash) использует `fork()` для создания нового процесса, а затем `exec()` для запуска команды, которую ввел пользователь.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    // Запускаем программу /bin/ls
    execl("/bin/ls", "ls", "-l", NULL);

    // Этот код выполнится только в случае ошибки execl
    perror("execl failed");
    return 1;
}
```

`fork()` и `exec()` часто используются вместе для запуска новых программ. Сначала `fork()` создает копию текущего процесса, а затем дочерний процесс использует `exec()`, чтобы заменить себя новой программой. Это позволяет родительскому процессу продолжать работу, в то время как дочерний процесс выполняет другую задачу.

### Итак:

- `fork()` создает копию процесса.
- `exec()` заменяет текущий процесс другой программой.
- `fork()` и `exec()` часто используются вместе для запуска новых программ параллельно.

---

# Pipe (неименованный канал)

Представим себе трубу, через которую можно передавать данные от одной программы к другой. Pipe (неименованный канал) – это механизм в операционной системе, который позволяет двум процессам общаться между собой, передавая данные в одном направлении. Это как односторонняя дорога для данных.

- **Неименованный:** Он называется "неименованным", потому что у него нет имени в файловой системе. Он существует только в памяти и используется только между процессами, которые имеют общего предка (например, родительский и дочерний процессы).
- **Однонаправленный:** Данные могут передаваться только в одном направлении: от одного процесса (пишущего) к другому (читающему).
- **Буфер:** Pipe работает как буфер. Пишущий процесс записывает данные в pipe, а читающий процесс считывает данные из pipe. Если pipe пуст, читающий процесс блокируется до тех пор, пока в pipe не появятся данные. Если pipe заполнен, пишущий процесс блокируется до тех пор, пока читающий процесс не освободит место.

**Как это работает:**

1. **Создание:** Сначала создается pipe с помощью функции `pipe()`. Эта функция создает два файловых дескриптора: один для чтения и один для записи.
2. **Fork:** Затем обычно вызывается `fork()`, чтобы создать дочерний процесс.
3. **Закрытие неиспользуемых дескрипторов:** В родительском процессе закрывается дескриптор для чтения, а в дочернем процессе закрывается дескриптор для записи. Это делается для того, чтобы каждый процесс имел только необходимые дескрипторы.
4. **Общение:** Родительский процесс может писать данные в pipe через дескриптор для записи, а дочерний процесс может читать данные из pipe через дескриптор для чтения.

**Для чего это нужно:**

Pipe используется для обмена данными между процессами, которые выполняются одновременно. Это особенно полезно, когда один процесс генерирует данные, а другой процесс обрабатывает эти данные.

- **Пример:** Командная оболочка (bash) использует pipe для соединения нескольких команд вместе. Например, команда `ls -l | grep "myfile"` соединяет вывод команды `ls -l` с вводом команды `grep "myfile"`.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2]; // Массив для хранения файловых дескрипторов pipe
    pid_t pid;

    // Создаем pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Создаем дочерний процесс
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Дочерний процесс (читатель)
        close(pipefd[1]);          // Закрываем дескриптор для записи

        char buf[256];
        ssize_t bytes_read;

        // Читаем данные из pipe
        bytes_read = read(pipefd[0], buf, sizeof(buf));
        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("Дочерний процесс получил: %.*s\n", (int)bytes_read, buf);

        close(pipefd[0]);          // Закрываем дескриптор для чтения
        exit(EXIT_SUCCESS);

    } else {
        // Родительский процесс (писатель)
        close(pipefd[0]);          // Закрываем дескриптор для чтения

        char message[] = "Привет от родительского процесса!";

        // Пишем данные в pipe
        write(pipefd[1], message, strlen(message));

        close(pipefd[1]);          // Закрываем дескриптор для записи
        wait(NULL);                // Ждем завершения дочернего процесса
        exit(EXIT_SUCCESS);
    }

    return 0;
}
```

- pipe(int p[2]) создаёт два дескриптора: p[0] — read end, p[1] — write end. Это односторонняя очередь байтов.
- Запись данных одним концом делает их доступными другому. Когда все записи закрываются, чтение вернёт EOF (0 байт).
- При чтении/записи нужно всегда закрывать неиспользуемые концы в каждом процессе — иначе EOF не наступит, и процессы могут ожидать бесконечно.
- pipe имеет ограниченную емкость (обычно несколько KB). POSIX гарантирует атомарность записи до PIPE_BUF (обычно 4096 байт) — полезно для логики, если нескольким писателям нужно не мешать друг другу.

# Протоколы обмена данными через pipe

- "Строковая" схема: родитель отправляет строки, дочерний читает построчно (getline / fgets). Удобно, но надо быть осторожным с буферизацией.
  
  - **Описание:** В этой схеме данные передаются в виде строк, разделенных символом новой строки (`\n`). Родительский процесс записывает строки в pipe, а дочерний процесс читает строки построчно, используя функции, такие как `getline()` или `fgets()`.
  
  - **Преимущества:**
    
    - Простота реализации: Легко писать и читать строки.
    - Удобство для текстовых данных: Подходит для передачи текстовых данных, таких как логи, конфигурационные файлы или команды.
  
  - **Недостатки:**
    
    - Ограничение на тип данных: Не подходит для передачи бинарных данных или данных, содержащих символы новой строки.
    - Проблема с буферизацией: Если родительский процесс пишет данные быстрее, чем дочерний процесс читает, pipe может заполниться, что приведет к блокировке родительского процесса. Также возможны проблемы с буферизацией на стороне читателя (например, `fgets` может прочитать меньше, чем доступно в pipe).
    - Необходимость обработки ошибок: Нужно проверять, что `getline()` или `fgets()` успешно прочитали строку, и обрабатывать ошибки.

- "Длина + тело": сначала посылаешь 4 байта длины, затем данные. Работает для произвольных данных и больших блоков.*
  
  - **Описание:** В этой схеме сначала передается длина данных (обычно в виде 4-байтного целого числа), а затем сами данные. Дочерний процесс сначала читает длину, а затем читает указанное количество байт из pipe.
  
  - **Преимущества:**
    
    - Подходит для произвольных данных: Может использоваться для передачи любых типов данных, включая бинарные данные.
    - Подходит для больших блоков данных: Позволяет передавать большие объемы данных без проблем с буферизацией (если правильно реализовано).
    - Явное указание размера: У получателя есть точная информация о том, сколько байт нужно прочитать.
  
  - **Недостатки:**
    
    - Сложность реализации: Требует более сложной логики для записи и чтения данных.
    - Надежность: Важно обеспечить правильную передачу длины данных. Если длина передана неверно, это может привести к ошибкам при чтении данных.

> [!IMPORTANT]
> 
> В задании используются строки произвольной длины — getline() в дочерних программах удобна, но на стороне записи лучше использовать fputs/puts и потом fflush, либо write().

- **Атомарность записи:** Важно помнить, что запись в pipe может быть не атомарной, если размер записываемых данных превышает размер буфера pipe (обычно 4096 байт или больше). Это означает, что данные могут быть перемешаны с данными от других процессов, если несколько процессов одновременно пишут в один и тот же pipe. В схеме "длина + тело" это особенно важно учитывать при записи длины и тела данных.
- **Обработка ошибок:** Всегда необходимо проверять возвращаемые значения функций `read()` и `write()` и обрабатывать возможные ошибки.
- **Закрытие pipe:** Важно закрывать дескрипторы pipe после завершения работы с ними, чтобы избежать утечек файловых дескрипторов.

> [!IMPORTANT]
> 
> Выбор между этими двумя схемами зависит от конкретных требований задачи. Если нужно передавать только текстовые данные, и простота реализации важнее, то можно использовать "строковую" схему. Если нужно передавать произвольные данные или большие блоки данных, то лучше использовать схему "длина + тело". В любом случае, необходимо тщательно продумать протокол обмена данными и обеспечить его надежную реализацию.

---

# Буферизация stdio — частая ловушка

- stdio (fwrite/fputs/printf) имеет уровни буферизации:
  - Терминал: stdout — line-buffered (сброс при '\n').
  - Pipe/file: stdout — full-buffered (сброс только при заполнении буфера или при fflush/exit).
- Последствие: если ты записываешь строку из child1 в stdout, который перенаправлен в pipe, данные могут "застрять" в буфере, пока не заполнится буфер. Решения:
  - Использовать fflush(stdout) после записи строки;
  - Отключить буферизацию stdout: setvbuf(stdout, NULL, _IONBF, 0);
  - Использовать низкоуровневую write(fd, buf, len), которая не буферится stdio.
- Проверяй поведение с маленькими строками; если результаты не приходят — часто виновата буферизация.

# Закрытие лишних концов pipe и почему это важно

- В каждом процессе надо закрывать все дескрипторы, которые не используются этим процессом. Иначе:
  
  - EOF не наступит (если есть лишний писатель — read не вернёт 0).
  - Поведение приложения неверно: ожидание ввода никогда не завершится.
1. **Правильное определение конца файла (EOF):**
   
   - Когда процесс пытается прочитать из pipe, он может столкнуться с ситуацией, когда в pipe нет данных. Если все процессы, имеющие открытый дескриптор для записи в этот pipe, закроют свои дескрипторы, то при попытке чтения из pipe будет возвращен EOF (конец файла), что означает, что больше данных не будет.
   - **Проблема без закрытия:** Если процесс, который не пишет в pipe, не закроет свой дескриптор для записи, то операционная система будет считать, что потенциально в pipe еще могут быть записаны данные. В этом случае, при попытке чтения из pipe, процесс будет блокироваться (ожидать данные) бесконечно, даже если родительский процесс уже записал все данные и завершился

2. **Предотвращение утечек файловых дескрипторов:**
   
   - Каждый открытый файловый дескриптор занимает ресурс в операционной системе. Если не закрывать неиспользуемые дескрипторы, то программа может исчерпать лимит открытых файловых дескрипторов, что приведет к ошибкам

3. **Корректное поведение приложения:**
   
   - Представим себе, что дочерний процесс ожидает ввод из pipe. Если родительский процесс завершил запись, но не закрыл дескриптор для записи, дочерний процесс будет ждать ввода вечно, так как он не получит сигнал EOF. Это может привести к зависанию приложения.

Вот пример, который привёл `Gemini`

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h> // Для wait()

int main() {
    int pipefd[2];
    pid_t pid;

    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Дочерний процесс (читатель)

        // Важно: Закрываем дескриптор для записи в дочернем процессе,
        // так как он здесь не используется.
        close(pipefd[1]);

        char buf[256];
        ssize_t bytes_read;

        bytes_read = read(pipefd[0], buf, sizeof(buf) - 1); // -1 чтобы всегда был запас для '\0'
        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        } else if (bytes_read == 0) {
            printf("Дочерний процесс: pipe закрыт, больше данных нет.\n");
        } else {
            buf[bytes_read] = '\0'; // Добавляем нулевой символ
            printf("Дочерний процесс получил: %s\n", buf);
        }

        // Важно: Закрываем дескриптор для чтения после использования.
        close(pipefd[0]);
        exit(EXIT_SUCCESS);

    } else {
        // Родительский процесс (писатель)

        // Важно: Закрываем дескриптор для чтения в родительском процессе,
        // так как он здесь не используется.
        close(pipefd[0]);

        char message[] = "Привет от родительского процесса!";
        write(pipefd[1], message, strlen(message));

        // Важно: Закрываем дескриптор для записи после записи данных.
        close(pipefd[1]);

        // Ждем завершения дочернего процесса, чтобы избежать зомби.
        wait(NULL);
        exit(EXIT_SUCCESS);
    }

    return 0;
}
```

---

# EOF и сигналы

- Когда все писатели pipe закрыты, чтение вернёт 0 (EOF).
- При попытке писать в pipe без читателя процесс получит сигнал SIGPIPE (по умолчанию — завершение процесса). Можно перехватить SIGPIPE или проверять код возврата write (-1, errno=EPIPE). Для лабораторной лучше обработать закрытие аккуратно — не полагаться на перехват SIGPIPE, но знать о нём.

> [!WARNING]
> 
> Ctrl+C -> SIGINT прерывает процессы; учти поведение при тестировании.

# Zombie-процессы и wait/waitpid

- Если дочерний завершился, но родитель не вызвал wait/waitpid, дочерний становится "зомби" — запись о статусе остаётся в таблице процессов.
- Родитель должен вызывать waitpid(pid, &status, 0) чтобы получить код возврата и избежать зомби.
- Если parent сам завершается, init (PID 1) принимает детей и убирает зомби.

---

# Реализация

### getline() и fgets:

В стандартной библиотеке C (stdio.h, string.h) нет функции, которая автоматически выделяет память и читает строку произвольной длины через fgets или sscanf.

- fgets требует заранее выделенный буфер фиксированного размера.
- sscanf работает с уже считанной строкой, но не выделяет память.

Для чтения строки произвольной длины стандартными средствами C обычно используют либо POSIX getline (на Linux), либо пишут свою функцию с realloc, как я показал выше.

В Windows и ANSI C такой функции нет — только ручная реализация или сторонние библиотеки.

Если нужна кроссплатформенная работа, используйте свой вариант с realloc. Если работаете на Linux, можно использовать getline.

POSIX (Portable Operating System Interface) — это стандарт, определяющий интерфейсы операционных систем, чтобы программы могли работать на разных Unix-подобных системах (Linux, macOS и др.) без изменений. В POSIX входят расширения для C, такие как функция getline.

ANSI (American National Standards Institute) — это организация, которая стандартизирует языки программирования, в том числе C. ANSI C — это стандарт языка C, который гарантирует совместимость кода на всех платформах, но не включает дополнительные функции POSIX.

Кратко:

- ANSI C — базовый стандарт языка C, работает везде.
- POSIX — расширение для Unix-систем, добавляет дополнительные функции и возможности.

Так как мы пишем программу. которая будет запускаться на linux, мы можем не придерживаться стандартов ANSI, так как мы будем взаимодействовать с процессами на Linux.

В любом случае приведу пример, как можно написать свою функцию для считывания строк произвольной длины:

```c
har *read_string_line() {
    size_t size = 128; // Начальный размер буфера строки
    size_t len = 0; // Начальная длина = 0
    char *buffer = malloc(size); // Выделяем память под строку

    if (!buffer) return NULL; // Проверка выделения памяти
     
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        buffer[len++] = c; // Доабвляем символ в строку
        if (len == size) {
            size *= 2; // Увеличиваем буфер в случае переполнения
            char *new_buffer = realloc(buffer, size);
            if (!new_buffer) {
                free(buffer);
                return NULL;
            }
            buffer = new_buffer;
        }
    }
    buffer[len] = '\0';
    return buffer;
}
```





# Цвет в терминале

- `"\x1b[31m"` — делает текст красным (обычно для вывода от дочернего процесса).
- `"\x1b[32m"` — делает текст зелёным (например, для родительского процесса).

Как это работает:

- `\x1b` — это escape-символ (код 27).
- `[31m` — команда для терминала: 31 — красный, 32 — зелёный.

Чтобы использовать цвет, просто добавьте эти макросы в строку вывода:

```c
printf("%sВаш текст%s", RED_COLOR, "\x1b[0m");
```

`\x1b[0m` — сбрасывает цвет обратно на стандартный.

Важно: такие коды работают в большинстве терминалов Linux/macOS и в некоторых эмуляторах терминала Windows (например, Windows Terminal, PowerShell, но не всегда в стандартном cmd.exe).

Вы можете использовать другие коды для разных цветов:

- 30 — чёрный
- 31 — красный
- 32 — зелёный
- 33 — жёлтый
- 34 — синий
- 35 — фиолетовый
- 36 — бирюзовый
- 37 — белый

Пример:

```c
printf("%sКрасный текст%s\n", RED_COLOR, "\x1b[0m");
printf("%sЗелёный текст%s\n", GREEN_COLOR, "\x1b[0m");
```



# exit и макрос для сообщения системе об ошибке

`exit(EXIT_FAILURE)` — это вызов функции `exit()` из библиотеки `<stdlib.h>`, которая завершает выполнение программы, возвращая операционной системе код ошибки. Макрос `EXIT_FAILURE` предоставляет системно-зависимое значение, сигнализирующее операционной системе о неудачном завершении программы.
