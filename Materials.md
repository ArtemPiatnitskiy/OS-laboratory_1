# Полезная информация

#### Что это?

Тут я собрал информацию, которая была для меня полезной, во время решения данной лабораторной работы.

В процессе решения возникают вопросы, в которых необходимо разобраться. Информацию я нахожу в интернете, или спрашиваю у нейросетей.

В случае, если у меня возникает какой-то вопрос, найденную информацию я сохраняю сюда.

Это помогает **глубже** разобраться в вопросе и сделать для себя материал, который поможет понять и запомнить важные моменты и понятия.

---

# Процессы — что это и как они организованы

- Процесс — это экземпляр выполняемой программы. У каждого процесса своя виртуальная память, таблица открытых файлов (file descriptors), ID процесса (PID), родитель (PPID) и набор ресурсов (регистры, текущее состояние).
- Контекст процесса: текст (код), данные (heap, global), стек, таблица дескрипторов файлов.
- Когда процесс создаётся, ОС создает ему отдельный адресный простор — поэтому два процесса не мешают друг другу напрямую (только через механизмы IPC).

# Threads (потоки) — отличия от процессов

- Поток (thread) — лёгкий поток выполнения внутри процесса. Потоки одного процесса разделяют память и дескрипторы файлов.
- Из-за разделяемой памяти потоки легче синхронизировать, но и легче допустить гонки (race conditions).
- В контексте задания мы используем процессы (`fork` + `exec`), не потоки; это важно, потому что дочерние процессы должны быть разными программами.

# File descriptors (дескрипторы файлов)

Файловый дескриптор — это уникальный числовой идентификатор, который операционная система присваивает открытому файлу, устройству, каналу или другому ресурсу ввода-вывода. Он позволяет процессам обращаться к этим ресурсам, управлять ими и выполнять операции чтения-записи данных. В Unix-подобных системах дескрипторы используются для взаимодействия с файлами, каталогами, сокетами и устройствами, а стандартные потоки ввода, вывода и ошибок имеют дескрипторы 0, 1 и 2 соответственно.

1. **Открытие ресурса:** 
   
   Когда программа открывает файл или создает другой объект ввода-вывода, операционная система выделяет для него запись в своей таблице и присваивает ей уникальный числовой дескриптор. 

2. **Использование дескриптора:** 
   
   Процесс использует этот дескриптор в качестве ссылки для выполнения системных вызовов, таких как чтение, запись или закрытие. 

3. **Таблица дескрипторов:** 
   
   Каждый процесс имеет свою таблицу открытых дескрипторов. В этой таблице индекс — это сам дескриптор, а значение — структура данных, хранящая информацию об открытом ресурсе. ([Полезный материал](https://serverspace.ru/support/glossary/deskriptor-fajla/?utm_source=google.com&utm_medium=organic&utm_campaign=google.com&utm_referrer=google.com))
- В UNIX-подобных системах дескриптор — это целое число, индекс таблицы открытых дескрипторов в процессе.
- **Стандартные дескрипторы**: Это заранее определенные дескрипторы, которые автоматически открыты для каждого процесса:0 — стандартный ввод (stdin).1 — стандартный вывод (stdout).2 — стандартный вывод ошибок (stderr).
- Файловые дескрипторы наследуются при fork(): дочерний процесс получает копию таблицы дескрипторов (указывающую на те же открытые файлы/пайпы). При exec() дескрипторы остаются открытыми, если не установлен флаг close-on-exec (FD_CLOEXEC).
- dup/dup2/dup3 позволяют "переназначить" дескрипторы: dup2(fd, STDIN_FILENO) заменит stdin новым fd.

## Как файлы получают дескрипторы

Обычно файловые дескрипторы выделяются последовательно. Есть пул свободных номеров. Когда вы создаете новый файл или открываете существующий, ему присваивается номер. Следующий файл получает очередной номер — например, 101, 102, 103 и так далее.

Дескриптор для каждого процесса является уникальным.

<img title="" src="https://content.timeweb.com/assets/4c3522f2-3c03-4c64-9583-60107791b801.png?width=600&height=295" alt="" data-align="center">

---

# fork() и exec() — как создают процессы

- `fork()` — клонирует процесс: возвращает **0** в дочернем, **PID** дочернего в родительском. После `fork()` родитель и ребёнок продолжают с той же точки.
- `execve` (и семейство `exec*`) заменяет текущий процесс новым образом программы, сохраняя PID. Часто вызывают fork(), затем в дочернем exec чтобы запустить другую программу.
- Практический паттерн: `parent: create pipes -> fork child -> in child: set up dup2() для stdin/stdout -> exec(child-program).`

## fork()

- `fork()` создает новый процесс, который является точной копией родительского процесса. Этот новый процесс называется дочерним процессом.
- **Как работает:**
  1. Когда вызывается `fork()`, операционная система создает дубликат адресного пространства родительского процесса. Это включает в себя копию кода, данных, стека, открытых файлов и других ресурсов.
  2. После создания дочернего процесса оба процесса (родительский и дочерний) продолжают выполнение с точки вызова `fork()`.
  3. `fork()` возвращает разные значения в родительском и дочернем процессах:
     - В родительском процессе `fork()` возвращает PID (идентификатор процесса) дочернего процесса.
     - В дочернем процессе `fork()` возвращает 0.
     - В случае ошибки `fork()` возвращает отрицательное значение.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid;

    pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        // Это дочерний процесс
        printf("Дочерний процесс: PID = %d, Родительский PID = %d\n", getpid(), getppid());
    } else {
        // Это родительский процесс
        printf("Родительский процесс: PID = %d, Дочерний PID = %d\n", getpid(), pid);
    }

    return 0;
}
```

По сути fork - это клонирование исходного процесса

## exec()

`exec()` – это функция, которая заменяет текущую программу другой программой. Это не клонирование, а скорее "перевоплощение".

- **Что происходит:** Когда вызывается `exec()`, текущий процесс заменяется новой программой. Код, данные и другие ресурсы текущего процесса заменяются ресурсами новой программы.

- **Возвращаемое значение:** `exec()` возвращает значение только в случае ошибки. Если вызов `exec()` успешен, текущая программа будет заменена новой, и дальнейший код в текущей программе не будет выполнен.

- **Для чего это нужно:** `exec()` используется для запуска других программ из текущей программы. Например, командная оболочка (вроде bash) использует `fork()` для создания нового процесса, а затем `exec()` для запуска команды, которую ввел пользователь.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    // Запускаем программу /bin/ls
    execl("/bin/ls", "ls", "-l", NULL);

    // Этот код выполнится только в случае ошибки execl
    perror("execl failed");
    return 1;
}
```

`fork()` и `exec()` часто используются вместе для запуска новых программ. Сначала `fork()` создает копию текущего процесса, а затем дочерний процесс использует `exec()`, чтобы заменить себя новой программой. Это позволяет родительскому процессу продолжать работу, в то время как дочерний процесс выполняет другую задачу.

## Семейство Exec

`exec` и `execv` - это функции из семейства `exec`, которые используются в Unix-подобных операционных системах для замены текущего процесса новым процессом. Разница между ними заключается в способе передачи аргументов новой программе. Чтобы было понятнее, давайте разберемся сперва с семейством `exec`.

**Семейство функций `exec`**

Семейство `exec` включает в себя несколько функций, которые выполняют одну и ту же задачу: заменяют текущий процесс новым процессом, загружая и запуская новую программу. Все функции `exec` начинаются с префикса `exec` и отличаются суффиксами, которые указывают на способ передачи аргументов и указания пути к исполняемому файлу.

- **Общая идея:** Функции `exec` не создают новый процесс, а заменяют текущий процесс. Это значит, что PID (идентификатор процесса) остается тем же, но код, данные, куча и стек процесса полностью заменяются новой программой.

- **Возврат:** Функции `exec` возвращают управление только в случае ошибки. Если функция выполнилась успешно, текущий процесс заменяется новой программой, и дальнейший код в текущей программе не выполняется.

- **Основные функции:**
  
  - `execl` (exec list): принимает путь к исполняемому файлу и список аргументов в качестве отдельных параметров.
  - `execv` (exec vector): принимает путь к исполняемому файлу и массив строк (вектор) в качестве аргументов.
  - `execle` (exec list environment): как `execl`, но также принимает массив переменных окружения.
  - `execve` (exec vector environment): как `execv`, но также принимает массив переменных окружения.
  - `execlp` (exec list path): как `execl`, но ищет исполняемый файл в каталогах, указанных в переменной окружения `PATH`.
  - `execvp` (exec vector path): как `execv`, но ищет исполняемый файл в каталогах, указанных в переменной окружения `PATH`.

## **`exec` vs `execv`**

Теперь давай сравним `execl` и `execv`:

- **`execl` (exec list):**
  
  - Принимает аргументы новой программы как список отдельных параметров.
  
  - Первый аргумент - это путь к исполняемому файлу.
  
  - Затем идут аргументы, которые будут переданы новой программе.
  
  - Последним аргументом должен быть `NULL`, чтобы обозначить конец списка аргументов.
  
  - **Пример:**
    
    ```c
    #include <unistd.h>
    int main() {
        execl("/bin/ls", "ls", "-l", NULL);
        // Этот код выполнится только в случае ошибки
        perror("execl failed");
        return 1;
    }
    ```

- **`execv` (exec vector):**
  
  - Принимает аргументы новой программы как массив строк (вектор).
  
  - Первый аргумент - это путь к исполняемому файлу.
  
  - Второй аргумент - это массив строк, где `argv[0]` - это имя программы (обычно совпадает с именем исполняемого файла), а остальные элементы - аргументы.
  
  - Массив должен заканчиваться `NULL`.
  
  - **Пример:**
    
    ```c
    #include <unistd.h>
    int main() {
        char *args[] = {"ls", "-l", NULL};
        execv("/bin/ls", args);
        // Этот код выполнится только в случае ошибки
        perror("execv failed");
        return 1;
    }
    ```

**Главное отличие:**

Основное отличие между `execl` и `execv` заключается в способе передачи аргументов. `execl` принимает аргументы как список отдельных параметров, а `execv` принимает аргументы как массив строк.

**Когда что использовать:**

- Использовать `execl`, если у нас небольшое количество аргументов, и они известны во время компиляции.
- Использовать `execv`, если у нас переменное количество аргументов, или они формируются динамически во время выполнения программы (например, из ввода пользователя).

**Пример использования `execvp` (нахождение программы в PATH):**

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    char *args[] = {"ls", "-l", NULL};
    execvp("ls", args); // Ищем "ls" в PATH
    perror("execvp failed");
    return 1;
}
```

В этом примере `execvp` найдет исполняемый файл `ls` в одном из каталогов, перечисленных в переменной окружения `PATH`, и запустит его с аргументами `-l`.

### Итак:

- `fork()` создает копию процесса.
- `exec()` заменяет текущий процесс другой программой.
- `fork()` и `exec()` часто используются вместе для запуска новых программ параллельно.

---

# Pipe (неименованный канал)

Представим себе трубу, через которую можно передавать данные от одной программы к другой. Pipe (неименованный канал) – это механизм в операционной системе, который позволяет двум процессам общаться между собой, передавая данные в одном направлении. Это как односторонняя дорога для данных.

- **Неименованный:** Он называется "неименованным", потому что у него нет имени в файловой системе. Он существует только в памяти и используется только между процессами, которые имеют общего предка (например, родительский и дочерний процессы).
- **Однонаправленный:** Данные могут передаваться только в одном направлении: от одного процесса (пишущего) к другому (читающему).
- **Буфер:** Pipe работает как буфер. Пишущий процесс записывает данные в pipe, а читающий процесс считывает данные из pipe. Если pipe пуст, читающий процесс блокируется до тех пор, пока в pipe не появятся данные. Если pipe заполнен, пишущий процесс блокируется до тех пор, пока читающий процесс не освободит место.

**Как это работает:**

1. **Создание:** Сначала создается pipe с помощью функции `pipe()`. Эта функция создает два файловых дескриптора: один для чтения и один для записи.
2. **Fork:** Затем обычно вызывается `fork()`, чтобы создать дочерний процесс.
3. **Закрытие неиспользуемых дескрипторов:** В родительском процессе закрывается дескриптор для чтения, а в дочернем процессе закрывается дескриптор для записи. Это делается для того, чтобы каждый процесс имел только необходимые дескрипторы.
4. **Общение:** Родительский процесс может писать данные в pipe через дескриптор для записи, а дочерний процесс может читать данные из pipe через дескриптор для чтения.

**Для чего это нужно:**

Pipe используется для обмена данными между процессами, которые выполняются одновременно. Это особенно полезно, когда один процесс генерирует данные, а другой процесс обрабатывает эти данные.

- **Пример:** Командная оболочка (bash) использует pipe для соединения нескольких команд вместе. Например, команда `ls -l | grep "myfile"` соединяет вывод команды `ls -l` с вводом команды `grep "myfile"`.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2]; // Массив для хранения файловых дескрипторов pipe
    pid_t pid;

    // Создаем pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // Создаем дочерний процесс
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Дочерний процесс (читатель)
        close(pipefd[1]);          // Закрываем дескриптор для записи

        char buf[256];
        ssize_t bytes_read;

        // Читаем данные из pipe
        bytes_read = read(pipefd[0], buf, sizeof(buf));
        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("Дочерний процесс получил: %.*s\n", (int)bytes_read, buf);

        close(pipefd[0]);          // Закрываем дескриптор для чтения
        exit(EXIT_SUCCESS);

    } else {
        // Родительский процесс (писатель)
        close(pipefd[0]);          // Закрываем дескриптор для чтения

        char message[] = "Привет от родительского процесса!";

        // Пишем данные в pipe
        write(pipefd[1], message, strlen(message));

        close(pipefd[1]);          // Закрываем дескриптор для записи
        wait(NULL);                // Ждем завершения дочернего процесса
        exit(EXIT_SUCCESS);
    }

    return 0;
}
```

- pipe(int p[2]) создаёт два дескриптора: p[0] — read end, p[1] — write end. Это односторонняя очередь байтов.
- Запись данных одним концом делает их доступными другому. Когда все записи закрываются, чтение вернёт EOF (0 байт).
- При чтении/записи нужно всегда закрывать неиспользуемые концы в каждом процессе — иначе EOF не наступит, и процессы могут ожидать бесконечно.
- pipe имеет ограниченную емкость (обычно несколько KB). POSIX гарантирует атомарность записи до PIPE_BUF (обычно 4096 байт) — полезно для логики, если нескольким писателям нужно не мешать друг другу.

# Протоколы обмена данными через pipe

- "Строковая" схема: родитель отправляет строки, дочерний читает построчно (getline / fgets). Удобно, но надо быть осторожным с буферизацией.
  
  - **Описание:** В этой схеме данные передаются в виде строк, разделенных символом новой строки (`\n`). Родительский процесс записывает строки в pipe, а дочерний процесс читает строки построчно, используя функции, такие как `getline()` или `fgets()`.
  
  - **Преимущества:**
    
    - Простота реализации: Легко писать и читать строки.
    - Удобство для текстовых данных: Подходит для передачи текстовых данных, таких как логи, конфигурационные файлы или команды.
  
  - **Недостатки:**
    
    - Ограничение на тип данных: Не подходит для передачи бинарных данных или данных, содержащих символы новой строки.
    - Проблема с буферизацией: Если родительский процесс пишет данные быстрее, чем дочерний процесс читает, pipe может заполниться, что приведет к блокировке родительского процесса. Также возможны проблемы с буферизацией на стороне читателя (например, `fgets` может прочитать меньше, чем доступно в pipe).
    - Необходимость обработки ошибок: Нужно проверять, что `getline()` или `fgets()` успешно прочитали строку, и обрабатывать ошибки.

- "Длина + тело": сначала посылаешь 4 байта длины, затем данные. Работает для произвольных данных и больших блоков.*
  
  - **Описание:** В этой схеме сначала передается длина данных (обычно в виде 4-байтного целого числа), а затем сами данные. Дочерний процесс сначала читает длину, а затем читает указанное количество байт из pipe.
  
  - **Преимущества:**
    
    - Подходит для произвольных данных: Может использоваться для передачи любых типов данных, включая бинарные данные.
    - Подходит для больших блоков данных: Позволяет передавать большие объемы данных без проблем с буферизацией (если правильно реализовано).
    - Явное указание размера: У получателя есть точная информация о том, сколько байт нужно прочитать.
  
  - **Недостатки:**
    
    - Сложность реализации: Требует более сложной логики для записи и чтения данных.
    - Надежность: Важно обеспечить правильную передачу длины данных. Если длина передана неверно, это может привести к ошибкам при чтении данных.

> [!IMPORTANT]
> 
> В задании используются строки произвольной длины — getline() в дочерних программах удобна, но на стороне записи лучше использовать fputs/puts и потом fflush, либо write().

- **Атомарность записи:** Важно помнить, что запись в pipe может быть не атомарной, если размер записываемых данных превышает размер буфера pipe (обычно 4096 байт или больше). Это означает, что данные могут быть перемешаны с данными от других процессов, если несколько процессов одновременно пишут в один и тот же pipe. В схеме "длина + тело" это особенно важно учитывать при записи длины и тела данных.
- **Обработка ошибок:** Всегда необходимо проверять возвращаемые значения функций `read()` и `write()` и обрабатывать возможные ошибки.
- **Закрытие pipe:** Важно закрывать дескрипторы pipe после завершения работы с ними, чтобы избежать утечек файловых дескрипторов.

> [!IMPORTANT]
> 
> Выбор между этими двумя схемами зависит от конкретных требований задачи. Если нужно передавать только текстовые данные, и простота реализации важнее, то можно использовать "строковую" схему. Если нужно передавать произвольные данные или большие блоки данных, то лучше использовать схему "длина + тело". В любом случае, необходимо тщательно продумать протокол обмена данными и обеспечить его надежную реализацию.

---

# Буферизация stdio — частая ловушка

- stdio (fwrite/fputs/printf) имеет уровни буферизации:
  - Терминал: stdout — line-buffered (сброс при '\n').
  - Pipe/file: stdout — full-buffered (сброс только при заполнении буфера или при fflush/exit).
- Последствие: если ты записываешь строку из child1 в stdout, который перенаправлен в pipe, данные могут "застрять" в буфере, пока не заполнится буфер. Решения:
  - Использовать fflush(stdout) после записи строки;
  - Отключить буферизацию stdout: setvbuf(stdout, NULL, _IONBF, 0);
  - Использовать низкоуровневую write(fd, buf, len), которая не буферится stdio.
- Проверяй поведение с маленькими строками; если результаты не приходят — часто виновата буферизация.

# Закрытие лишних концов pipe и почему это важно

- В каждом процессе надо закрывать все дескрипторы, которые не используются этим процессом. Иначе:
  
  - EOF не наступит (если есть лишний писатель — read не вернёт 0).
  - Поведение приложения неверно: ожидание ввода никогда не завершится.
1. **Правильное определение конца файла (EOF):**
   
   - Когда процесс пытается прочитать из pipe, он может столкнуться с ситуацией, когда в pipe нет данных. Если все процессы, имеющие открытый дескриптор для записи в этот pipe, закроют свои дескрипторы, то при попытке чтения из pipe будет возвращен EOF (конец файла), что означает, что больше данных не будет.
   - **Проблема без закрытия:** Если процесс, который не пишет в pipe, не закроет свой дескриптор для записи, то операционная система будет считать, что потенциально в pipe еще могут быть записаны данные. В этом случае, при попытке чтения из pipe, процесс будет блокироваться (ожидать данные) бесконечно, даже если родительский процесс уже записал все данные и завершился

2. **Предотвращение утечек файловых дескрипторов:**
   
   - Каждый открытый файловый дескриптор занимает ресурс в операционной системе. Если не закрывать неиспользуемые дескрипторы, то программа может исчерпать лимит открытых файловых дескрипторов, что приведет к ошибкам

3. **Корректное поведение приложения:**
   
   - Представим себе, что дочерний процесс ожидает ввод из pipe. Если родительский процесс завершил запись, но не закрыл дескриптор для записи, дочерний процесс будет ждать ввода вечно, так как он не получит сигнал EOF. Это может привести к зависанию приложения.

Вот пример, который привёл `Gemini`

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h> // Для wait()

int main() {
    int pipefd[2];
    pid_t pid;

    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Дочерний процесс (читатель)

        // Важно: Закрываем дескриптор для записи в дочернем процессе,
        // так как он здесь не используется.
        close(pipefd[1]);

        char buf[256];
        ssize_t bytes_read;

        bytes_read = read(pipefd[0], buf, sizeof(buf) - 1); // -1 чтобы всегда был запас для '\0'
        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        } else if (bytes_read == 0) {
            printf("Дочерний процесс: pipe закрыт, больше данных нет.\n");
        } else {
            buf[bytes_read] = '\0'; // Добавляем нулевой символ
            printf("Дочерний процесс получил: %s\n", buf);
        }

        // Важно: Закрываем дескриптор для чтения после использования.
        close(pipefd[0]);
        exit(EXIT_SUCCESS);

    } else {
        // Родительский процесс (писатель)

        // Важно: Закрываем дескриптор для чтения в родительском процессе,
        // так как он здесь не используется.
        close(pipefd[0]);

        char message[] = "Привет от родительского процесса!";
        write(pipefd[1], message, strlen(message));

        // Важно: Закрываем дескриптор для записи после записи данных.
        close(pipefd[1]);

        // Ждем завершения дочернего процесса, чтобы избежать зомби.
        wait(NULL);
        exit(EXIT_SUCCESS);
    }

    return 0;
}
```

---

# EOF и сигналы

- Когда все писатели pipe закрыты, чтение вернёт 0 (EOF).
- При попытке писать в pipe без читателя процесс получит сигнал SIGPIPE (по умолчанию — завершение процесса). Можно перехватить SIGPIPE или проверять код возврата write (-1, errno=EPIPE). Для лабораторной лучше обработать закрытие аккуратно — не полагаться на перехват SIGPIPE, но знать о нём.

> [!WARNING]
> 
> Ctrl+C -> SIGINT прерывает процессы; нужно учесть поведение при тестировании.

# Zombie-процессы и wait/waitpid

- Если дочерний завершился, но родитель не вызвал wait/waitpid, дочерний становится "зомби" — запись о статусе остаётся в таблице процессов.
- Родитель должен вызывать waitpid(pid, &status, 0) чтобы получить код возврата и избежать зомби.
- Если parent сам завершается, init (PID 1) принимает детей и убирает зомби.

## **Что такое `waitpid`?**

`waitpid` - это системный вызов, который позволяет родительскому процессу ожидать изменения состояния дочернего процесса. Это более гибкая версия функции `wait`, которая ожидает завершения любого дочернего процесса. `waitpid` позволяет указать, какой именно дочерний процесс нужно ожидать, и какие события нужно отслеживать.

**Аргументы `waitpid`:**

`pid_t waitpid(pid_t pid, int *status, int options);`

1. **`pid_t pid`:** Это идентификатор процесса (PID), который нужно ожидать. Этот аргумент определяет, какой дочерний процесс будет отслеживаться. Возможные значения:
   
   - `pid > 0`: Ожидать дочерний процесс с PID, равным `pid`.
   - `pid == 0`: Ожидать любой дочерний процесс, у которого группа процессов совпадает с группой процессов вызывающего процесса. (Группа процессов обычно совпадает с группой процессов родителя).
   - `pid == -1`: Ожидать любой дочерний процесс. Это поведение аналогично функции `wait`.
   - `pid < -1`: Ожидать любой дочерний процесс, у которого ID группы процессов равен `abs(pid)`. (Абсолютное значение `pid`).

2. **`int *status`:** Это указатель на целочисленную переменную, в которую будет записан статус завершения дочернего процесса. Если `status` не равен `NULL`, то `waitpid` запишет информацию о том, как завершился дочерний процесс, в эту переменную. Эту информацию можно извлечь с помощью макросов, таких как `WIFEXITED`, `WEXITSTATUS`, `WIFSIGNALED`, `WTERMSIG` (о них поговорим ниже). Если тебе не нужен статус завершения, можно передать `NULL` в качестве этого аргумента.

3. **`int options`:** Это битовая маска, которая определяет дополнительные опции ожидания. Некоторые из наиболее часто используемых опций:
   
   - `0`: Обычное блокирующее ожидание. `waitpid` будет блокировать вызывающий процесс до тех пор, пока не произойдет изменение состояния дочернего процесса (завершение, остановка или продолжение).
   - `WNOHANG`: Если ни один дочерний процесс не готов к изменению состояния, `waitpid` немедленно вернет управление, вернув 0. Это позволяет неблокирующее ожидание.
   - `WUNTRACED`: Также сообщать об остановленных (но не отслеженных) дочерних процессах. Остановка процесса может произойти, например, при использовании отладчика.
   - `WCONTINUED`: Также сообщать о дочерних процессах, которые были продолжены после остановки (только начиная с Linux 2.6.10).
   - `WEXITED`: Ожидать только дочерние процессы, которые завершились.

**Указатель на статус (`int *status`)**

Как я уже упоминал, аргумент `status` - это указатель на `int`, в котором функция `waitpid` возвращает информацию о том, как завершился дочерний процесс. Чтобы получить полезную информацию из этого статуса, используются специальные макросы:

- **`WIFEXITED(status)`:** Возвращает `true` (ненулевое значение), если дочерний процесс завершился нормально (вызвал `exit` или вернул значение из `main`).
- **`WEXITSTATUS(status)`:** Если `WIFEXITED(status)` вернул `true`, то этот макрос возвращает код завершения дочернего процесса (значение, переданное в `exit` или возвращенное из `main`). Код завершения находится в диапазоне от 0 до 255.
- **`WIFSIGNALED(status)`:** Возвращает `true`, если дочерний процесс был завершен сигналом.
- **`WTERMSIG(status)`:** Если `WIFSIGNALED(status)` вернул `true`, то этот макрос возвращает номер сигнала, который завершил дочерний процесс.
- **`WIFSTOPPED(status)`:** Возвращает `true`, если дочерний процесс в данный момент остановлен.
- **`WSTOPSIG(status)`:** Если `WIFSTOPPED(status)` вернул `true`, то этот макрос возвращает номер сигнала, который остановил дочерний процесс.
- **`WIFCONTINUED(status)`:** (Начиная с Linux 2.6.10) Возвращает `true`, если дочерний процесс был продолжен после остановки.

**Пример использования `waitpid`:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    int status;

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Дочерний процесс
        printf("Дочерний процесс: мой PID = %d\n", getpid());
        exit(7); // Завершаемся с кодом 7
    } else {
        // Родительский процесс
        printf("Родительский процесс: PID дочернего процесса = %d\n", pid);

        // Ожидаем завершения конкретного дочернего процесса (pid)
        if (waitpid(pid, &status, 0) == -1) {
            perror("waitpid");
            exit(EXIT_FAILURE);
        }

        if (WIFEXITED(status)) {
            printf("Родительский процесс: Дочерний процесс завершился нормально с кодом %d\n", WEXITSTATUS(status));
        } else if (WIFSIGNALED(status)) {
            printf("Родительский процесс: Дочерний процесс был завершен сигналом %d\n", WTERMSIG(status));
        } else {
            printf("Родительский процесс: Дочерний процесс завершился как-то иначе\n");
        }
        exit(EXIT_SUCCESS);
    }
}
```

В этом примере родительский процесс создает дочерний процесс, затем ожидает его завершения с помощью `waitpid`. После завершения дочернего процесса родительский процесс анализирует статус завершения и выводит информацию о том, как завершился дочерний процесс.

**Возвращаемое значение `waitpid`:**

- В случае успеха `waitpid` возвращает PID завершившегося дочернего процесса.
- Если указана опция `WNOHANG` и ни один дочерний процесс не готов к изменению состояния, `waitpid` возвращает 0.
- В случае ошибки `waitpid` возвращает -1 и устанавливает `errno`.

**Зачем использовать `waitpid` вместо `wait`?**

`waitpid` предоставляет больше контроля над тем, какие дочерние процессы ожидаются и какие события отслеживаются. Это особенно полезно в ситуациях, когда:

- У родительского процесса есть несколько дочерних процессов, и нужно ожидать завершения конкретного процесса.
- Нужно неблокирующее ожидание (с помощью опции `WNOHANG`).
- Нужно отслеживать остановку и продолжение дочерних процессов (для отладки или управления процессами).

---

# Реализация

### getline() и fgets:

В стандартной библиотеке C (stdio.h, string.h) нет функции, которая автоматически выделяет память и читает строку произвольной длины через fgets или sscanf.

- fgets требует заранее выделенный буфер фиксированного размера.
- sscanf работает с уже считанной строкой, но не выделяет память.

Для чтения строки произвольной длины стандартными средствами C обычно используют либо POSIX getline (на Linux), либо пишут свою функцию с realloc, как я показал выше.

В Windows и ANSI C такой функции нет — только ручная реализация или сторонние библиотеки.

Если нужна кроссплатформенная работа, используйте свой вариант с realloc. Если работаете на Linux, можно использовать getline.

POSIX (Portable Operating System Interface) — это стандарт, определяющий интерфейсы операционных систем, чтобы программы могли работать на разных Unix-подобных системах (Linux, macOS и др.) без изменений. В POSIX входят расширения для C, такие как функция getline.

ANSI (American National Standards Institute) — это организация, которая стандартизирует языки программирования, в том числе C. ANSI C — это стандарт языка C, который гарантирует совместимость кода на всех платформах, но не включает дополнительные функции POSIX.

Кратко:

- ANSI C — базовый стандарт языка C, работает везде.
- POSIX — расширение для Unix-систем, добавляет дополнительные функции и возможности.

Так как мы пишем программу. которая будет запускаться на linux, мы можем не придерживаться стандартов ANSI, так как мы будем взаимодействовать с процессами на Linux.

В любом случае приведу пример, как можно написать свою функцию для считывания строк произвольной длины:

```c
har *read_string_line() {
    size_t size = 128; // Начальный размер буфера строки
    size_t len = 0; // Начальная длина = 0
    char *buffer = malloc(size); // Выделяем память под строку

    if (!buffer) return NULL; // Проверка выделения памяти

    int c;
    while ((c = getchar()) != '\n' && c != EOF) {
        buffer[len++] = c; // Доабвляем символ в строку
        if (len == size) {
            size *= 2; // Увеличиваем буфер в случае переполнения
            char *new_buffer = realloc(buffer, size);
            if (!new_buffer) {
                free(buffer);
                return NULL;
            }
            buffer = new_buffer;
        }
    }
    buffer[len] = '\0';
    return buffer;
}
```

# Цвет в терминале

- `"\x1b[31m"` — делает текст красным (обычно для вывода от дочернего процесса).
- `"\x1b[32m"` — делает текст зелёным (например, для родительского процесса).

Как это работает:

- `\x1b` — это escape-символ (код 27).
- `[31m` — команда для терминала: 31 — красный, 32 — зелёный.

Чтобы использовать цвет, просто добавьте эти макросы в строку вывода:

```c
printf("%sВаш текст%s", RED_COLOR, "\x1b[0m");
```

`\x1b[0m` — сбрасывает цвет обратно на стандартный.

Важно: такие коды работают в большинстве терминалов Linux/macOS и в некоторых эмуляторах терминала Windows (например, Windows Terminal, PowerShell, но не всегда в стандартном cmd.exe).

Вы можете использовать другие коды для разных цветов:

- 30 — чёрный
- 31 — красный
- 32 — зелёный
- 33 — жёлтый
- 34 — синий
- 35 — фиолетовый
- 36 — бирюзовый
- 37 — белый

Пример:

```c
printf("%sКрасный текст%s\n", RED_COLOR, "\x1b[0m");
printf("%sЗелёный текст%s\n", GREEN_COLOR, "\x1b[0m");
```

# exit и макрос для сообщения системе об ошибке

`exit(EXIT_FAILURE)` — это вызов функции `exit()` из библиотеки `<stdlib.h>`, которая завершает выполнение программы, возвращая операционной системе код ошибки. Макрос `EXIT_FAILURE` предоставляет системно-зависимое значение, сигнализирующее операционной системе о неудачном завершении программы.

### Что делает perror:

**Perror** печатает текстовое описание текущего errno. errno устанавливается ядром/библиотекой в момент системного вызова (например, write) и остаётся доступным в процессе до следующего изменения. Поэтому perror должна вызываться сразу после неудачного вызова, пока errno ещё релевантен.

- Как write сообщает об ошибке: при ошибке write возвращает -1 и устанавливает errno в соответствующий код ошибки (EINTR, EPIPE, EAGAIN, EBADF и т.д.). Вы проверяете return == -1 и затем вызываете perror("msg") — perror печатает строку "msg: <описание errno>".

---

# Strace

- `strace` — утилита для перехвата и логирования системных вызовов и сигналов процесса в Linux. С её помощью видно, какие именно системные вызовы программа выполняет (open/read/write/execve/fork/mmap и т.д.), с какими аргументами и с каким результатом — это именно то, что обычно требуется в задачах по ОС.
1. Зачем нужен strace
- Понять поведение программы на уровне ядра: какие файлы открываются, какие сокеты подключаются, какие процессы создаются, какие области памяти выделяются.
- Отладка ошибок: почему программа не может открыть файл (ENOENT/EACCES), почему падает (сигнал SIGSEGV/SIGBUS), почему долго выполняется (узкие места по системным вызовам).
- Верификация соответствия варианту лабораторной: по списку и последовательности системных вызовов можно показать, что используются именно те вызовы, которые требуются.
- Быстрая диагностика взаимодействия с ОС без исходников или без отладки на уровне языка.
2. Немного о том, как это работает «внутри»
- strace использует механизм ptrace (интерфейс ядра для отладки) для перехвата точек входа/выхода системных вызовов процесса. Когда процесс делает syscall, ядро передаёт управление ptrace‑наблюдателю (strace), который может считать регистры, аргументы, результат и затем дать процессу продолжить.
- strace переводит номера системных вызовов и коды ошибок в удобочитаемые имена и строки (например, errno 2 -> ENOENT).
- Ограничения: ptrace требует соответствующих прав (обычно root или владелец процесса и допустимая политика ptrace). seccomp‑фильтры и некоторые песочницы могут мешать трассировке. Также strace может заметно замедлять работу отслеживаемого процесса.
3. Установка (популярные дистрибутивы)
- Ubuntu / Debian: 
  
  ```bash
  sudo apt update sudo apt | install strace
  ```

- Fedora: 
  
  ```bash
  sudo dnf install strace
  ```

- CentOS / RHEL (epel при необходимости): 
  
  ```bash
  sudo yum install strace
  ```

- Arch Linux: 
  
  ```bash
  sudo pacman -S strace
  ```

- macOS: strace как таковой для macOS нет; можно использовать dtruss (на базе dtrace) или инструменты типа DTrace / dtruss. Для Linux‑совместимой работы рекомендую Linux VM.

- Сборка из исходников: git clone [GitHub - strace/strace: strace is a diagnostic, debugging and instructional userspace utility for Linux](https://github.com/strace/strace.git) cd strace ./bootstrap (или autoreconf -fi) ./configure make sudo make install — возможно, придётся установить dev‑зависимости: gcc, make, autoconf, automake, libtool, pkgconfig и т.д.  
  
  **Проверка: strace -V strace --version**
4. Права и безопасные настройки
- Для отслеживания процессов, принадлежащих другому пользователю, либо setuid‑программ, обычно нужен root.
- Начиная с некоторых версий ядра/дистрибутивов действует Yama ptrace_scope (/proc/sys/kernel/yama/ptrace_scope). Если ptrace_scope = 1, то обычные пользователи не могут ptrace процессов других пользователей, не принадлежащих им. Для разработки можно временно переключить: sudo sysctl -w kernel.yama.ptrace_scope=0
- Seccomp и контейнеры: если программа установила seccomp‑фильтр, strace может быть блокирован/неполноценен.
5. **Основные** ключи и приёмы использования (с примерами)
- Запустить программу под strace и вывести всё в stdout: strace ./a.out
- Вывод в файл (удобно для анализа и затем комментирования): strace -o trace.txt ./a.out
- Следовать за дочерними процессами (fork/exec): `strace -f -o trace.txt ./a.out` или `strace -ff -o trace ./a.out` (при -ff появятся файлы trace.`<pid>` для каждого процесса)
- Прикрепиться к уже запущенному процессу: sudo strace -p 12345 -o attach.txt
- Ограничить трассируемые классы/вызовы:
  - По классам (файлы, сеть, процесс и т.д.): -e trace=file (все файловые операции: open, stat, unlink…) -e trace=network (socket, connect, accept…) -e trace=process (fork, vfork, clone, execve, wait*)
  - По конкретным syscalls: -e trace=execve,open,read,write,connect
- Подробные опции:
  - `-s N` — показывать строки до длины N (по умолчанию ~32). Чтобы видеть полные строковые аргументы, ставьте больший N (например, `-s 200`).
  - `-f` — Следовать за дочерними процессами (fork/exec):
  - `-v` — не сокращать одинаковые аргументы/структуры (более подробный вывод).
  - `-x` — не printable символы показывать в hex
  - `-xx` — распечатать ещё больше данных в hex
  - `-t` — префикс времени (HH:MM:SS)
  - `-tt` — префикс времени с микросекундами (точность)
  - `-r` — относительное время (время между вызовами)
  - `-T` — показывать время выполнения каждого системного вызова
  - `-c` — собрать сводную статистику (количество вызовов, общ. время, ошибки): strace -c -o stat.txt ./a.out
  - `-y` — печатать путь, связанный с файловыми дескрипторами (полезно при dup/pipe)
  - `-p PID` — attach к PID
  - `-o file` — записать вывод в файл (иначе выводится на stderr)
6. Формат вывода и как его читать (пример и объяснение) Пример строки `strace: execve("./prog", ["./prog", "arg"], 0x7ffd5b2d) = 0 <0.000023>` Объяснение:
   - `execve` — имя системного вызова
   - `("./prog", ["./prog", "arg"], 0x7ffd5b2d)` — аргументы вызова (здесь: путь, argv, envp)
   - `= 0` — возвращаемое значение (0 = успех). Если возвращено `-1` , далее будет (errno X) указано: `open("file", O_RDONLY) = -1 ENOENT (No such file or directory)`
   - `<0.000023>` — время выполнения вызова в секундах (если включён -T) Если включён префикс времени (-t/-tt/-r), перед строкой будет соответствующая временная метка. Если трассируется несколько процессов (-f), строки нередко префиксируются [pid 1234] (или вывод разделён на файлы при -ff).

### Часто встречающиеся системные вызовы и их значение (коротко)

- execve — выполнить новую программу
- fork/clone/vfork — порождение процесса/потока
- wait/waitpid/wait4 — ожидание завершения дочернего
- open/openat/stat/lstat — операции с файловой системой, получение метаданных
- read/write/pread/pwrite — ввод/вывод
- close — закрыть дескриптор
- mmap/munmap/brk — выделение/освобождение памяти
- socket/connect/accept/send/recv — сетевые операции
- ioctl — управление устройствами/файловыми дескрипторами (часто сложно декодируется)
- kill/tgkill/rt_sigaction/rt_sigprocmask — работа с сигналами
- gettimeofday/clock_gettime — получение времени
- uname/getpid/getppid — информация о процессе/системе
