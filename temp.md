Да — лучше считывать stdin по строкам в цикле getline и либо сразу обрабатывать/пересылать каждую строку (стриминг), либо аккумулировать их в один динамический буфер (concatenate). Оба варианта корректны — вот кратко про них и пример кода.

1) Рекомендуемый (стриминг) — чтение по строкам и немедленная отправка/обработка (не требует одномоментного хранения всего ввода):
- экономно по памяти,
- простая обработка/передача в pipe,
- EOF определяется, когда getline возвращает -1.

Пример (читает строки и пишет в pipe1):
````c
// пример: читать по строкам и писать сразу в pipe1
char *line = NULL;
size_t cap = 0;
ssize_t nread;
while ((nread = getline(&line, &cap, stdin)) != -1) {
    if (write_all(pipe1[1], line, (size_t)nread) == -1) { perror("write"); break; }
}
free(line);
/* потом close(pipe1[1]) чтобы сообщить EOF дочернему процессу */
````

2) Аккумуляция всех строк в единый динамический буфер (если нужно иметь весь stdin в памяти как одну C-строку):
- используем getline в цикле и конкатенируем через realloc,
- следим за размерами и ставим '\0' в конце,
- полезно, если child должен получить весь текст как единая строка.

Пример накопления:
````c
// пример: собрать весь stdin в один буфер (динамически)
char *acc = NULL;
size_t acc_cap = 0;
size_t acc_len = 0;
char *line = NULL;
size_t linecap = 0;
ssize_t nread;
while ((nread = getline(&line, &linecap, stdin)) != -1) {
    if (acc_len + (size_t)nread + 1 > acc_cap) {
        size_t newcap = acc_cap ? acc_cap * 2 : 4096;
        while (newcap < acc_len + (size_t)nread + 1) newcap *= 2;
        char *p = realloc(acc, newcap);
        if (!p) { perror("realloc"); free(acc); acc = NULL; break; }
        acc = p;
        acc_cap = newcap;
    }
    memcpy(acc + acc_len, line, (size_t)nread);
    acc_len += (size_t)nread;
}
free(line);
if (acc) {
    acc[acc_len] = '\0'; // C-строка
    /* теперь acc содержит весь stdin; можно обработать и вывести/записать в pipe */
    free(acc);
}
````

Советы:
- Для больших потоков предпочтителен стриминг (вариант 1).
- Всегда проверяй возвраты getline/realloc/write и корректно закрывай write-end pipe, чтобы дать EOF дочерним процессам.
- Если нужно сохранить границы строк — просто конкатенируй вместе с прочитанными '\n' (getline их даёт).
- Используй экспоненциальный рост при realloc, чтобы не делать много копирований.

Хочешь — вставлю один из этих фрагментов прямо в твой main.c (укажи, какой вариант предпочитаешь).